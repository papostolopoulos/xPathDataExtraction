<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <link rel="icon"
      type="image/png"
      href="favicon.ico">
    <meta charset="utf-8">
    <title>How Performant - Test the performance of JavaScript functions</title>
    <!-- <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script> -->
    <script src="vue.js"></script>

    <style media="screen">
      *{
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: sans-serif;
      }

      h1{
        font-size: 3vw;
      }

      #main{
        display: grid;
        grid-template-columns: 33.3% 66.6%;
        grid-template-rows: 100%;
        grid-template-areas:
        "sectionPasteParams sectionPasteFunctions"
        "sectionPasteParams sectionPasteFunctions";
        height: 95vh;
      }

      .sectionPasteParams{
        padding: 10px;
        background-color: lightblue;
        grid-area: sectionPasteParams;
        overflow: auto;
      }

      .divNumOfArgumentsSets{
        position: sticky;
        top: 0;
      }

      #inputNumOfArgumentsSets{
        width: 50px;
      }

      .divArgumentsSets{
        overflow: auto;
      }

      .divFunctionArgument{
        margin-top: 10px;
      }

      .textAreaArgumentsPaste{
        width: 100%;
        height: 10vh;
        padding: 5px;
        font-size: 0.8em;
      }

      .labelArgumentsDataTypes{
        margin-right: 10px;
      }

      .sectionPasteFunctions{
        grid-area: sectionPasteFunctions;
        display: flex;
        align-content: center;
        justify-content: center;
      }

      .sectionFunction1, .sectionFunction2{
        width: 50%;
        padding: 10px;
      }

      .divFunctionPasteArea{
        position: sticky;
        top: 0;
        height: 20vh;
      }

      .textAreaFunctionPaste{
        width: 100%;
        height: 100%;
        padding: 5px;
        font-size: 0.8em;
      }

      .sectionFunction1{
        background-color: lightgreen;
      }

      .sectionFunction2{
        background-color: pink;
      }

      #footer{
        background: rgb(0,0,0);
        height: 5vh;
        line-height: 5vh;
        text-align: center;
        font-size: 1.4rem;
        border-top: 3px solid black;
        color: white;
      }

      #footer a{
        color: white;
      }
    </style>
  </head>
  <body>
    <div id="container">
      <main id="main">
        <section class="sectionPasteParams">
          <div class="divNumOfArgumentsSets">
            <h1>Function arguments</h1>
            <label class="labelNumOfArgumentsSets">
              Enter number of function arguments:
              <input type="number"
              name="inputNumOfArgumentsSets"
              id="inputNumOfArgumentsSets"
              v-model="numOfArgumentsSets"
              @change="changeArgumentsArrLength()"
              min="0"
              max="20"
              width="4"
              >
            </label>
            <!-- <p>
              Paste your arguments in the following slots.
              One data type per slot.
              If you want to run your function multiple times and with different
              arguments each time then paste them in the same slot with a line break.
              If a different amount of arguments is going to be pasted on each slot,
              then the function will be run as many times as the slot with the most
              arguments pasted. In order to match the difference between arguments,
              then there will be an iteration of the less arguments in the final
              function invocations.
            </p> -->
          </div>



          <div class="divArgumentsSets" v-for="set in Number(numOfArgumentsSets)">
            <function-arg :id="'argSet' + set"></function-arg>
          </div>

        </section>



        <section class="sectionPasteFunctions">
          <section class="sectionFunction1">
            <div class="divFunctionPasteArea">
              <h1>Function 1</h1>
              <textarea
              id="textAreaFunction1"
              v-model="function1String"
              name="textAreaFunction1"
              class="textAreaFunctionPaste"
              placeholder="Paste your function in this field"
              ></textarea>
              <button type="button" name="button" @click="testFunctionPerformance()">test function</button>
            </div>

          </section>



          <section class="sectionFunction2">
            This is for function 2 - sectionFunction2
          </section>
        </section>


      </main>

      <footer id="footer">
        How Performant? Compare JavaScript functions |
        <a href="http://addeventlistener.xyz" target="_blank">@papostolopoulos</a> |
        May 2019
      </footer>
    </div>






    <script type="text/javascript">

//----Vue component----
      Vue.component('function-arg', {
        props: ["set"],
        data(){
          return {
            errorEntry: false,
            dataType: "string",
            textAreaValues: "",
            arrayElements: [],
            objectElements: {}
          }
        },
        methods:{
          //takes all the values in the textArea and splits them on every line break
          //Depending on the dataType selected, it converts them from string to the right
          //data type. Then it returns an array of all the elements.
          processTextAreaValues(){
            //if parameter slot is open but no string is entered, then return nothing
            // if(this.textAreaValues.length === 0) return;

            console.log("In the start of the processTextAreaValues()");
            this.errorEntry = false;
            let finalArr = [];
            let startArr = this.textAreaValues.split("\n");


            //If function selected
            if (this.dataType === "function"){
              console.log("selected data type = function");
              let functionsArr = this.textAreaValues.split(/(?<=\})\s+((?=function)|(?=(var|let|const)\s[A-z_\$]\w*\s*=\s*function))/);
              for (let i = 0; i < functionsArr.length; i++) {
                console.log("Result from function selection before the evalFunction:", functionsArr[i]);
                this.evalFunction(functionsArr[i]) === "error" ? this.errorEntry = true : finalArr.push(this.evalFunction(functionsArr[i]));
              }
            }

            //If object selected
            if (this.dataType === "object"){
              console.log("selected dataType = object");
              let objectsArr = this.textAreaValues.split(/\n(?=\{)/);
              for (let i = 0; i < objectsArr.length; i++) {
                objectsArr[i][0] === "{" ? objectsArr[i] = objectsArr[i] : objectsArr[i] = "{" + objectsArr[i];
                console.log("Result from function selection before the evalFunction:", objectsArr[i]);
                if (this.evalObject(objectsArr[i], this.objectElements) === "error") this.errorEntry = true;
                else {
                  this.objectElements = {};
                  this.arrayElements = [];
                  finalArr.push(this.evalObject(objectsArr[i]), this.objectElements);
                } //End of else
              }
            } //End of if object selected

            //If string selected - Not sure about this
            if (this.dataType === "string"){
              console.log("selected dataType = string");
              let stringsArr = this.textAreaValues.split(/\n/);

              //Find if there are tildas (`) in the strings. That might mean sentences
              //that are spanning to different lines so they need to be connected
              let pairTildas = this.textAreaValues.replace(/[^`]/g, "").length % 2 === 0;
              if (pairTildas) {
                for (let j = 0; j < stringsArr.length; j++) {
                  if (stringsArr[j][0] === "`" && stringsArr[j][stringsArr[j].length - 1] !== "`") {
                    let replaceStr = stringsArr[j];
                    let elemsCounter = 1;
                    for (var k = j+1; k < stringsArr.length; k++) {
                      replaceStr += stringsArr[k];
                      elemsCounter += 1;
                      if (stringsArr[k][stringsArr[k].length - 1] === "`") {
                        stringsArr.splice(j, elemsCounter, replaceStr);
                        break;
                      }
                    } //End of Second loop (k)

                  }
                } //End of first loop, j
              } //End of if(pairTildas)

              for (let i = 0; i < stringsArr.length; i++) {
                this.evalString(stringsArr[i]) === "error" ? this.errorEntry = true : finalArr.push(this.evalString(stringsArr[i]));
              }

            } //End of if this.dataType === string



            for (let i = 0; i < startArr.length; i++) {
              console.log("In the for loop for i:", i);

              //If array selected
              if (this.dataType === "array"){
                console.log("selected data type: array");
                if(this.evalArray(startArr[i], this.arrayElements) === "error") this.errorEntry = true;
                else {
                  this.arrayElements = [];
                  this.objectElements = {};
                  finalArr.push(this.evalArray(startArr[i], this.arrayElements));
                }
              }

              //If boolean selected
              if (this.dataType === "boolean")
                this.evalBoolean(startArr[i]) === "error" ? this.errorEntry = true : finalArr.push(this.evalBoolean(startArr[i]));
              //If null selected
              if (this.dataType === "null")
                this.evalNull(startArr[i]) === "error" ? this.errorEntry = true : finalArr.push(this.evalNull(startArr[i]));
              //If number selected
              if (this.dataType === "number")
                this.evalNumber(startArr[i]) === "error" ? this.errorEntry = true : finalArr.push(this.evalNumber(startArr[i]));
              //If regexp selected
              if (this.dataType === "regexp")
                this.evalRegExp(startArr[i]) === "error" ? this.errorEntry = true : finalArr.push(this.evalRegExp(startArr[i]));
              //If undefined selected
              if (this.dataType === "undefined")
                this.evalUndefined(startArr[i]) === "error" ? this.errorEntry = true : finalArr.push(this.evalUndefined(startArr[i]));
            } //End of for loop

            console.log("The array to be sent to the main component is:", finalArr);

            //Update the new data in the app component every time there is a change
            //in the textArea or the radio buttons
            app.$data.argumentsArr[this.argIdNum - 1] = finalArr;
          }, //End of processTextAreaValues


          //Evaluates if the array is properly structured
          evalArray(arrStr, arr) {
            if (arrStr === "[]") return arr;
            else {
              if (arrStr[0] !== "[" || arrStr[arrStr.length-1] !== "]"){
                console.log("In the error because the first or the last character of the string do not indicate an array");
                return "error";
              }
              else {
                console.log("In the else of the eval array. The arrStr before the slice:", arrStr);
                arrStr = arrStr.slice(1, arrStr.length-1);
                console.log("In the else of the eval array. The arrStr after the slice:", arrStr);
                let es5FunctionRegEx = "function\\s+[^0-9\\|°¬\\!#\\$%/\\(\\)\\?¡¿\\+\\{\\}\\[\\]:\\.\\,;@ª^\\*<>=\\&]*\\s*\\(([^\\|°¬\\!#\\$%/\\(\\)\\?¡¿\\+\\{\\}\\[\\]:\\.\\,;@ª^\\*<>=\\&]*,?\\s*)+\\)\\s*\\{.*\\}";
                let es6FunctionRegEx = "\\(([^\\|°¬\\!#\\$%/\\(\\)\\?¡¿\\+\\{\\}\\[\\]:\\.\\,;@ª^\\*<>=\\&]*,?\\s*)+\\)\\s*=>\\s*\\{.*\\}";

                //Number
                if(arrStr.search(/\d+(\.\d+)?,/) === 0 || arrStr.search(/\d+(\.\d+)?\s*$/) === 0) {
                  console.log("else if for number");
                  arr.push(Number(arrStr.match(/\d+(\.\d+)?/)[0]));
                  console.log(Number(arrStr.match(/\d+(\.\d+)?/)[0]));
                  arrStr = arrStr.slice(arrStr.match(/\d+(\.\d+)?/)[0].length + 1);
                  // arrStr = arrStr.slice(arrStr.indexOf(",") + 1);
                  arrStr = arrStr.trim();
                  console.log("end of else if");
                  return this.evalArray("[" + arrStr + "]", arr);
                }

                //true
                else if (arrStr.indexOf("true,") === 0 || arrStr.search(/true\s*$/) === 0) {
                  console.log("else if for true");
                  arr.push(true);
                  arrStr = arrStr.slice(5);
                  arrStr = arrStr.trim();
                  return this.evalArray("[" + arrStr + "]", arr);
                }

                //false
                else if (arrStr.indexOf("false,") === 0 || arrStr.search(/false\s*$/) === 0) {
                  console.log("else if for false");
                  arr.push(false);
                  arrStr = arrStr.slice(6);
                  arrStr = arrStr.trim();
                  return this.evalArray("[" + arrStr + "]", arr);
                }

                //null
                else if (arrStr.indexOf("null,") === 0 || arrStr.search(/null\s*$/) === 0) {
                  console.log("else if for null");
                  arr.push(null);
                  arrStr = arrStr.slice(5);
                  arrStr = arrStr.trim();
                  return this.evalArray("[" + arrStr + "]", arr);
                }

                //Undefined
                else if (arrStr.indexOf("undefined,") === 0 || arrStr.search(/undefined\s*$/) === 0) {
                  console.log("else if for undefined");
                  arr.push(undefined);
                  arrStr = arrStr.slice(10);
                  arrStr = arrStr.trim();
                  return this.evalArray("[" + arrStr + "]", arr);
                }

                //string
                else if (arrStr.search(/["'`]/) === 0) {
                  console.log("else if for string");
                  let firstQuote = arrStr[0];
                  if (arrStr.indexOf(firstQuote + ",") > 0) {
                    arr.push(arrStr.substring(1, arrStr.indexOf(firstQuote + ",")));
                    arrStr = arrStr.slice(arrStr.indexOf(firstQuote + ",") + 2);
                    arrStr = arrStr.trim()
                  }
                  else if (arrStr.lastIndexOf(firstQuote) === arrStr.length-1) {
                      arr.push(arrStr.substring(1, arrStr.length-1));
                      arrStr = "";
                  }
                  return this.evalArray("[" + arrStr + "]", arr);
                }

                //function es5 es6
                else if (arrStr.search(RegExp(es5FunctionRegEx)) === 0 ||  arrStr.search(RegExp(es6FunctionRegEx)) === 0) {

                  console.log("else if for function");
                  let params = arrStr.slice(arrStr.indexOf("(") + 1, arrStr.indexOf(")")).split(/,\s*/);
                  console.log("params are", params);
                  console.log("arrStr is", arrStr.match(/function\s+[^0-9\|°¬\!#\$%/\(\)\?¡¿\+\{\}\[\]:.\,;@ª^\*<>=\&]*\s*\(([^\|°¬\!#\$%/\(\)\?¡¿\+\{\}\[\]:\.\,;@ª^\*<>=\&]*,?\s*)+\)\s*\{.*\}/));
                  //If there is a function and separated by a comma with other array elements
                  if(arrStr.search(RegExp(es5FunctionRegEx + ",")) !== -1 ||
                  arrStr.search(RegExp(es6FunctionRegEx + ",")) !== -1){
                    console.log("In if for functions");
                    params.push(arrStr.slice(arrStr.indexOf("{") + 1, arrStr.indexOf("}, ")));
                    arr.push(new Function(...params));
                    arrStr = arrStr.slice(arrStr.indexOf("}, ") + 3).trim();
                    console.log("arrStr is", arrStr);
                  }
                  //if the function is the last element of the array
                  else if ((RegExp(es5FunctionRegEx).test(arrStr) && arrStr.match(RegExp(es5FunctionRegEx))[0].length === arrStr.length) ||
                  RegExp(es6FunctionRegEx).test(arrStr) && arrStr.match(RegExp(es6FunctionRegEx))[0].length === arrStr.length) {
                    console.log("in else if for functions");
                    params.push(arrStr.slice(arrStr.indexOf("{") + 1, arrStr.lastIndexOf("}")));
                    arr.push(new Function(...params));
                    arrStr = "";
                    console.log(arrStr);
                  }
                  return this.evalArray("[" + arrStr + "]", arr);
                }

                //array
                else if (arrStr.indexOf("[") === 0){
                  console.log("else if for array");

                  if (this.sliceArrObj("[", "]", arrStr)) {
                    let arrStrSubstring = arrStr.substring(0, this.sliceArrObj("[", "]", arrStr));
                    console.log("arrStrSubstring is", arrStrSubstring);
                    //Push in arr array the function for evaluating arrays or objects (recursively), with the related substring
                    arr.push(this.evalArray(arrStrSubstring, []));

                    //slice the arrayString at the level of the substring
                    arrStr = arrStr.slice(this.sliceArrObj("[", "]", arrStr) + 1);
                    arrStr = arrStr.trim();
                    return this.evalArray("[" + arrStr + "]", arr);
                  }
                }

                //object
                else if (arrStr.indexOf("{") === 0){
                  console.log("else if for object");

                  if (this.sliceArrObj("{", "}", arrStr)) {
                    let arrStrSubstring = arrStr.substring(0, this.sliceArrObj("{", "}", arrStr));
                    console.log("arrStrSubstring is", arrStrSubstring);
                    //Push in arr array the function for evaluating objects, with the related substring
                    arr.push(this.evalObject(arrStrSubstring, {}));

                    //slice the arrayString at the level of the substring
                    arrStr = arrStr.slice(this.sliceArrObj("{", "}", arrStr) + 1);
                    arrStr = arrStr.trim();
                    return this.evalArray("[" + arrStr + "]", arr);
                  }
                }

                //There was no identification of any data type so error is returned
                else {
                  console.log("The data type was not matched");
                  return "error";
                }
              }
            } //End of top else
          }, //End of evalArray


          //Evaluates if the Boolean is properly structured
          evalBoolean(el){
            if (el.trim() === "true") return true;
            if (el.trim() === "false") return false;
            return "error";
          },


          //Evaluates if the function is properly structured
          evalFunction(el){
            el = el.trim();
            console.log("In evalFunction. The el in the evaFunction is:", el);

            if (!el.startsWith("function") ||
            !el.search(/(var|let|const)\s[A-z_\$]\w*\s*=\s*\(([A-z_\$]\w*,?\s*)*\)\s*=>/ !== 0) ||
            !el.endsWith("}")) return "error";

            let params = el.slice(el.indexOf("(") + 1, el.indexOf(")")).split(/,\s*/);
            params.push(el.slice(el.indexOf("{") + 1, el.lastIndexOf("}")));
            console.log("The function parameters are:", params);

            return new Function(...params);
          },


          //Evaluates if the null is properly structured
          evalNull(el){
            return el.trim() === "null" ? null : "error";
          },


          //Evaluates if the number is properly structured
          evalNumber(el){
            return isNaN(Number(el.trim())) ? "error" : Number(el);
          },


          //evaluates if the object is properly structured
          evalObject(el, obj){
            el = el.trim();
            if (el === "{}") return obj;

            if (!el.startsWith("{") || !el.endsWith("}")) return "error";
            console.log("In eval Object. el is", el, "Need to convert from string to object");

            //Put quotes in the keys of the object so it can pass the JSON.parse
            //Put quotes in all the "undefined" as well
            el = el
            .replace(/([\{,])(\s*)(\w+)(\s*)(:)/g, "$1$2\"$3\"$4$5") //Add quotes at the start and the end of the keys
            .replace(/(:\s+)(undefined)([,\n])/, "$1\"$2\"$3"); //put quotes around all the undefined
            console.log("After the addition of quotations in the keys:", el);

            // IF THERE IS A FUNCTION AS A VALUE OF ONE OF THE OBJECT'S PROPERTIES:
            // 1. Create a variable that is pulling out all the functions from the obj.
            // 2. replace unecessary text at the beginning and end of each element.
            // 3. Replace all the double quotes to single quotes and replace all the line breaks
            if ((/(:\s)(function\s*\((?:[^\|°¬\!#\$%/\(\)\?¡¿\+\{\}\[\]:\.\,;@ª^\*<>=\&]*,?\s*)*\)\s*\{[\S\s]+\})(,?\s)/g).test(el)) {
              let functionStrings =
              el
              .match(/(:\s)(function\s*\((?:[^\|°¬\!#\$%/\(\)\?¡¿\+\{\}\[\]:\.\,;@ª^\*<>=\&]*,?\s*)*\)\s*\{[\S\s]+\})(,?\s)/g)
              .map((ele) => ele.slice(ele.indexOf("function"), ele.lastIndexOf("}") + 1))
              .map((elm) => elm.replace(/"/g, "'").replace(/\n/g, ""));
              console.log(functionStrings);

              //Replace all the function strings into "A function goes here"
              el = el.replace(/(:\s)(function\s*\((?:[^\|°¬\!#\$%/\(\)\?¡¿\+\{\}\[\]:\.\,;@ª^\*<>=\&]*,?\s*)*\)\s*\{[\S\s]+\})(,?\s)/g, "$1A function goes here$3");

              //Add all the functions back in the object as -cleaned- string formats
              while (functionStrings.length > 0) {
                el = el.replace(/A function goes here/, '"' + functionStrings.shift() + '"');
              }
            }


            //Parse the string into an object
            obj = JSON.parse(el);

            for(let key in obj){
              if (obj[key] === "undefined") obj[key] = undefined;
              if (/function.*\}/.test(obj[key])) {
                let params = obj[key].slice(obj[key].indexOf("(") + 1, obj[key].indexOf(")")).split(/,\s*/);
                params.push(obj[key].slice(obj[key].indexOf("{") + 1, obj[key].lastIndexOf("}")));

                obj[key] = new Function(...params);
              }

              //What if the string is an array?
            } //End of the for loop
            return obj;
          },


          // evaluates if the regular expression is properly structured
          evalRegExp(el){
            el = el.trim();
            let elFlags = el.slice(el.lastIndexOf("/") + 1);
            let flags = "igmsuy";
            let source = el.slice(1, el.lastIndexOf("/"));
            console.log(elFlags, flags, source);

            //The last character is not a /
            if (elFlags === 0 && el.length - 1 !== el.lastIndexOf("/")) return "error";

            //some of the flag characters are incorrect
            if (elFlags.length > 0) {
              for (var i = 0; i < elFlags.length; i++) {
                if (!flags.includes(elFlags[i])) return "error";
              }
            }

            //The first character is not a /
            if (el[0] !== "/") return "error";

            let sourceCheck = source.replace(/[^\(\)\[\]\{\}]/g, "");
            console.log(sourceCheck);

            while (sourceCheck.length > 0) {
              if (/\[\]/.test(sourceCheck) || /\(\)/.test(sourceCheck) || /\{\{/.test(sourceCheck)) {
                sourceCheck = sourceCheck.replace(/\[\]/, "").replace(/\(\)/, "").replace(/\{\}/, "");
              }
              else return "error";
            }

            return new RegExp(source, elFlags);
          },


          //Evaluates if the string is properly structured
          evalString(el){
            //Should I be removing the quotes or not?
            //How do I deal with tildas where the breaks are not indicating a
            //line break but rather a continuation of a sentence?
            //Get rid of extra quotation marks that might already exist at the input field
            console.log("In the evalString method");
            return el.replace(/^(?:["'`]+)?(.*[^"'`])(?:["'`]+)?\s*$/gm, "$1").trim();
          },


          //Evaluates if the undefined is properly structured
          evalUndefined(el){
            return el === "undefined" ? undefined : "error";
          },


          //finds if the opening and closing brackets are structured correctly
          //in an array or an object
          sliceArrObj(openBrkt, closeBrkt, arr) {
              let counter = 1;
              let subStr = arr.slice(1);
              for (let i = 0; i < subStr.length; i++) {
                if(subStr[i] === openBrkt) counter++;
                else if(subStr[i] === closeBrkt){
                  counter--;
                  if(counter === 0) return i+2;
                }
                else continue;
              } //End of for loop for substring
              return false;
          },

        }, //End of methods
        computed: {
          //Create the ID for the div tag that includes the arguments textArea
          argIdNum(){
            return this.$attrs.id.replace(/[A-z]/g, "");
          },
          // sendTextAreaValues(){
          //   return processTextAreaValues();
          // }

        },
        template:
        `
          <div class="divFunctionArgument" :key="set">
            <h2>Argument {{argIdNum}}</h2>
            <label class="labelArgumentsDataTypes">
              <textarea
                class="textAreaArgumentsPaste"
                placeholder="Enter the function's argument.\nIf you are entering more than one options for the same argument type, separate them with a line break"
                v-model="textAreaValues"
                @keyup="processTextAreaValues($event.target.value)">

              </textarea>
            </label>
            <h4>Argument data type:</h4>
            <div class="divLabelDataType">
              <form>
                <label class="labelArgumentsDataTypes">
                  Array:
                  <input type="radio" name="inputRadioDataType" value="array" v-model="dataType" @change="processTextAreaValues($event.target.value)">
                </label>
                <label class="labelArgumentsDataTypes">
                  Boolean:
                  <input type="radio" name="inputRadioDataType" value="boolean" v-model="dataType" @change="processTextAreaValues($event.target.value)">
                </label>
                <label class="labelArgumentsDataTypes">
                  Null:
                  <input type="radio" name="inputRadioDataType" value="null" v-model="dataType" @change="processTextAreaValues($event.target.value)">
                </label>
                <label class="labelArgumentsDataTypes">
                  Number:
                  <input type="radio" name="inputRadioDataType" value="number" v-model="dataType" @change="processTextAreaValues($event.target.value)">
                </label>
                <label class="labelArgumentsDataTypes">
                  Object literal:
                  <input type="radio" name="inputRadioDataType" value="object" v-model="dataType" @change="processTextAreaValues($event.target.value)">
                </label>
                <label class="labelArgumentsDataTypes">
                  RegExp:
                  <input type="radio" name="inputRadioDataType" value="regexp" v-model="dataType" @change="processTextAreaValues($event.target.value)">
                </label>
                <label class="labelArgumentsDataTypes">
                  String:
                  <input type="radio" name="inputRadioDataType" value="string" v-model="dataType" @change="processTextAreaValues($event.target.value)">
                </label>
                <label class="labelArgumentsDataTypes">
                  Undefined:
                  <input type="radio" name="inputRadioDataType" value="undefined" v-model="dataType" @change="processTextAreaValues($event.target.value)">
                </label>
                <label class="labelArgumentsDataTypes">
                  callback function:
                  <input type="radio" name="inputRadioDataType" value="function" v-model="dataType" @change="processTextAreaValues($event.target.value)">
                </label>
              </form>

            </div> <!--End of divLabelDataType-->

            <div class="divErrorEntries">
              <div class="divErrorEntry" v-show="errorEntry === true && dataType === 'array'">
                Incorrect array entry(ies). Make sure you have entered arrays that start and end with
                square brackets - [].
                Also make sure that each one of the array elements does not have any errors when entered (example: a mistyped function or a number with incorrect decimals).
                The values should be separated by a line break and without any extra
                line breaks at the end of the text.
              </div>
              <div class="divErrorEntry" v-show="errorEntry === true && dataType === 'boolean'">
                Incorrect boolean entry(ies). Make sure you have entered only boolean values (true, false).
                The values should be separated by a line break and without any extra
                line breaks at the end of the text.
              </div>
              <div class="divErrorEntry" v-show="errorEntry === true && dataType === 'function'">
                Incorrect function entry(ies). Make sure you have entered the function in
                the correct format, with opening and closing curly braces.
                The values should be separated by a line break and without any extra
                line breaks at the end of the text.
              </div>
              <div class="divErrorEntry" v-show="errorEntry === true && dataType === 'null'">
                Incorrect null entry(ies). Make sure you have entered only null values (null).
                The values should be separated by a line break and without any extra
                line breaks at the end of the text.
              </div>
              <div class="divErrorEntry" v-show="errorEntry === true && dataType === 'number'">
                Incorrect number entry(ies). Make sure you have entered only numeric values (integers or floats).
                The values should be separated by a line break and without any extra
                line breaks at the end of the text.
              </div>
              <div class="divErrorEntry" v-show="errorEntry === true && dataType === 'object'">
                Incorrect object literal entry(ies). Make sure you have entered
                an object that opens and closes with curly braces - {}.
                The values should be separated by a line break and without any extra
                line breaks at the end of the text.
              </div>
              <div class="divErrorEntry" v-show="errorEntry === true && dataType === 'regexp'">
                Incorrect regex entry(ies). Make sure you have entered a regular
                expression that  opens and closes with slashes.
                Make sure that the format of the regex (parenthesis, brackets etc)
                is correct. Make sure that the flags are correct.
                The values should be separated by a line break and without any extra
                line breaks at the end of the text.
              </div>
              <div class="divErrorEntry" v-show="errorEntry === true && dataType === 'undefined'">
                Incorrect undefined entry(ies). Make sure you have entered only "undefined" as a value.
                The values should be separated by a line break and without any extra
                line breaks at the end of the text.
              </div>
            </div>
          </div>
        `
      }); //End of Vue component







//----MAIN VUE INSTANCE----
      let app = new Vue({
        el: "#main",
        data: {
          numOfArgumentsSets: 0, //number of components - number of arguments for functions
          argumentsArr: [], //The array that has all the initial arguments
          function1String: "",
          function2String: "",
          hasError: false,
          maxElementsNum: 0 //The most number of elements that an argument set has
        },
        methods: {
          //updates the length of the argumentsArr based on the addition or subtraction
          //of new components
          changeArgumentsArrLength(){
            /*
            I need to decide if I want to keep this if statement or if an argument
            with an empty string should be placed every time I add a new textArea.
            The ternary operator that is commented out does that.
            This if statement just pops off an element every time I substract a text
            area.
            */
            while (Number(this.numOfArgumentsSets) < this.argumentsArr.length) {
              this.argumentsArr.pop();
            }
            // Number(this.numOfArgumentsSets) > this.argumentsArr.length ?
            // this.argumentsArr.push("") :
            // this.argumentsArr.pop();
          },


          //Evaluate the strings that are pasted in the textAreas and confirm they
          //are valid functions
          evalFunction(el){
            this.hasError = false;
            el = el.trim();
            console.log("In evalFunction. The el in the evaFunction is:", el);

            if (!el.startsWith("function") ||
            !el.search(/(var|let|const)\s[A-z_\$]\w*\s*=\s*\(([A-z_\$]\w*,?\s*)*\)\s*=>/ !== 0) ||
            !el.endsWith("}")) {
              this.hasError = true;
              return "";
            }

            let params = el.slice(el.indexOf("(") + 1, el.indexOf(")")).split(/,\s*/);
            params.push(el.slice(el.indexOf("{") + 1, el.lastIndexOf("}")));
            console.log("The function parameters are:", params);

            return new Function(...params);
          },



          testFunctionPerformance(){
            // if both function strings are empty, return without running function
            if (this.function1String === "" && this.function2String === "") return;

            //Create function. Evaluate if it is a valid function
            let function1 = this.function1String !== "" ? this.evalFunction(this.function1String) : "";
            let function2 = this.function2String !== "" ? this.evalFunction(this.function2String) : "";

            // If one of the tow functions has an error, return without running function
            if (function1 === "error" || function2 === "error") return;

            this.refreshArgumentsArr();

            //How can I make sure that if any elements are removed from the argument slots, this recalculates
            let leveledArguments = this.levelArguments();

            console.log("Invoking", function1());
            console.log("leveledArguments is ", leveledArguments);

            //need to iterate through each element of each argument and add it as
            //a param in the function to be invoked.
            for (var i = 0; i < leveledArguments.length; i++) {
              this.numOfArgumentsSets[i];
            }


          },


          /*Take all the array elements from this.argumensArr and convert them in
          array elements of the same length.*/
          levelArguments(){
            console.log("invoking levelArguments()");

            //Zero the this.maxElementsNum first
            this.maxElementsNum = 0;
            let args = this.argumentsArr.slice();

            if (this.argumentsArr.length === 0) return;


            // Iterate through all the elements of this.argumentsArr.
            // If the length of the element is larger than the this.maxElementsNum
            // then the this.maxElementsNum has to become equal to the element's length.
            for (let i = 0; i < this.argumentsArr.length; i++) {
              if (args[i].length > this.maxElementsNum) this.maxElementsNum = args[i].length;
            }


            // Iterate through all the elements of this.argumentsArr one more time
            // If the element's length is less than the this.maxElementsNum
            // Create a nested loop with i < element's length
            // push elements from the beginning of the element
            // every time after you push, check if the element's length is equal
            // to the this.maxElementsNum. If so, then break
            for (let j = 0; j < args.length; j++) {
              let element = args[j];
              console.log("Looping through j for loop. element is", element);
              if (element.length < this.maxElementsNum) {
                for (let k = 0; k < this.maxElementsNum; k++) {
                  args[j].push(element[k]);
                  if(args[j].length === this.maxElementsNum) break;
                }
              }
            }

            // this.refreshArgumentsArr();
            console.log("The argumentsArr is ", this.argumentsArr);
            return this.arrayFlip(args);
          }, //End of levelArguments()


          //used to return the array to its initial status
          refreshArgumentsArr(){
            for (var i = 0; i < app.$children.length; i++) {
              app.$children[i].processTextAreaValues();
            }

            //need to iterate through the children of the component
            //If the elements of the children are less or more than the elements
            //of each respective argument in the this.argumentsArr, then update
            //Should I create a separate property in the instance that updates from
            //The argumentsArr through the levelArguments?
          },


          arrayFlip(arr) {
            console.log("In the arrayFlip");
            let endArr = [];

            for (let i = 0; i < arr[0].length; i++) {
              endArr.push([]);
            }

            for (let j = 0; j < arr.length; j++) {
              for (let k = 0; k < arr[j].length; k++) {
                endArr[k].push(arr[j][k]);
              }
            }

            return endArr;
          }
        }, //End of methods
        computed: {
        } //End of computed
      });

    </script>

  </body>
</html>
